#!/opt/mesosphere/bin/python

import errno
import os
import random
import socket
import subprocess
import sys

from ctypes import cdll
import dns.query


BASE_CONTENTS = """# Generated by gen_resolvconf.py. Do not edit.
# Change configuration options by changing DC/OS cluster configuration.
# This file must be overwritten regularly for proper cluster operation around
# master failure.

options timeout:1
options attempts:3

"""

# Constants
MAX_SERVER_COUNT = 3
SPARTANS = ['198.51.100.1', '198.51.100.2', '198.51.100.3']

# We assume that RESOLVCONF_DIR_PATH is precreated
RESOLVCONF_DIR_PATH = '/var/lib/dcos/resolvconf'
RESOLVCONF_PATH = os.path.join(RESOLVCONF_DIR_PATH, 'resolv.conf')
DCOS_BIND_MOUNT_POINT = '/tmp/dcos'
FALLBACK_RESOLVCONF_PATH = os.path.join(DCOS_BIND_MOUNT_POINT, 'resolvconf/resolv.conf')
DNS_TEST_QUERY = 'ready.spartan'
DNS_TIMEOUT = 5
CLONE_NEWNS = 0x00020000

LIBC = cdll.LoadLibrary("libc.so.6")


def rm(filename):
    if os.path.isfile(filename) or os.path.islink(filename):
        os.unlink(filename)


def symlink(link_name, dst):
    '''Creates symlink. Idempotent. Equal to ln -sf'''
    try:
        os.symlink(dst, link_name)
    except FileExistsError:
        if os.path.islink(link_name) and os.readlink(link_name) == dst:
            return
        else:
            rm(link_name + '.tmp')
            os.symlink(dst, link_name + '.tmp')
            os.rename(link_name + '.tmp', link_name)


def check_server(addr):
    try:
        query = dns.message.make_query(DNS_TEST_QUERY, dns.rdatatype.ANY)
        result = dns.query.udp(query, addr, DNS_TIMEOUT)
        if len(result.answer) == 0:
            print('Skipping DNS server {}: no records for {}'.format(
                addr, DNS_TEST_QUERY), file=sys.stderr)
        else:
            return True
    except socket.gaierror as ex:
        print(ex, file=sys.stderr)
    except dns.exception.Timeout:
        print('Skipping DNS server {}: no response'.format(
            addr), file=sys.stderr)
    except:
        print("Unexpected error querying DNS for server \"{}\" exception: {}".format(
            addr, sys.exc_info()[1]))

    return False


def generate_resolv_conf(servers):
    contents = BASE_CONTENTS
    if 'SEARCH' in os.environ:
        contents += 'search {}\n'.format(os.environ['SEARCH'])
    for ns in servers:
        contents += 'nameserver {}\n'.format(ns)
    return contents


def replace_file_contents(filename, contents):
    rm(filename + '.tmp')
    # Generate the resolv.conf config
    with open(filename + '.tmp', 'w') as f:
        f.write(contents)

    # Move the temp file into place. This also takes care of
    # making the file at resolvconf_path not a symlink if it
    # was one (writing directly we would just update the
    # target of the symlink). systemd-resolved updates the
    # target of the symlink itself though, which results in fun
    # conflicting things like https://dcosjira.atlassian.net/browse/DCOS-305

    try:
        os.rename(filename + '.tmp', filename)
    except OSError as e:
        # fall back to old behavior because resolv.conf in dcos-docker
        # is a mount point that doesn't like getting renamed
        if e.errno == errno.EBUSY:
            print('Falling back to writing directly due to EBUSY on rename')
            with open(filename, 'w') as f:
                f.write(contents)
        else:
            raise


def usable_fallback_servers():
    fallback_servers = []
    for ns in os.environ['RESOLVERS'].split(','):
        ip, separator, port = ns.rpartition(':')
        if not separator:
            fallback_servers.append(ns)
            continue
        if port == '53':
            fallback_servers.append(ip)
            continue
        print('Skipping DNS server {}: non-default ports are not supported in /etc/resolv.conf'.format(ns),
              file=sys.stderr)
    return fallback_servers


def servers_with_spartans():
    # Check if Spartan is up
    spartans_up = []
    for ns in SPARTANS:
        if check_server(ns):
            spartans_up.append(ns)
    if len(spartans_up) > 0:
        return spartans_up
    else:
        # If Spartan is not up, fall back, and insert the upstreams
        fallback_servers = usable_fallback_servers()
        random.shuffle(fallback_servers)
        return fallback_servers[:MAX_SERVER_COUNT]


def ensure_mount():
    print('Ensuring mount', file=sys.stderr)
    if subprocess.call(['mountpoint', '-q', RESOLVCONF_DIR_PATH]) != 0:
        subprocess.check_call(['mount', '-t', 'tmpfs', 'none', RESOLVCONF_DIR_PATH])


def unshare(flags):
    LIBC.unshare(flags)
    subprocess.check_call(['mount', '--make-rprivate', 'none', '/'])
    subprocess.check_call(['mount', '-t', 'tmpfs', 'none', '/tmp'])
    os.mkdir(DCOS_BIND_MOUNT_POINT)
    subprocess.check_call(['mount', '--bind', '/var/lib/dcos', DCOS_BIND_MOUNT_POINT])


def ensure_symlink():
    print('Setting up symlink', file=sys.stderr)
    symlink('/etc/resolv.conf', RESOLVCONF_PATH)


def update_resolvconf():
    maybe_dcos_servers = servers_with_spartans()
    contents = generate_resolv_conf(maybe_dcos_servers)
    print('Updating {}'.format(RESOLVCONF_PATH))
    print(contents, file=sys.stderr)
    replace_file_contents(RESOLVCONF_PATH, contents)


def update_fallback_resolvconf():
    print('Writing fallback resolvconf: {}'.format(FALLBACK_RESOLVCONF_PATH), file=sys.stderr)
    fallback_servers = usable_fallback_servers()
    random.shuffle(fallback_servers)
    contents = generate_resolv_conf(fallback_servers)
    replace_file_contents(FALLBACK_RESOLVCONF_PATH, contents)


def main():
    ensure_mount()
    unshare(CLONE_NEWNS)
    update_resolvconf()
    update_fallback_resolvconf()
    ensure_symlink()
    sys.exit(0)


if __name__ == '__main__':
    main()
