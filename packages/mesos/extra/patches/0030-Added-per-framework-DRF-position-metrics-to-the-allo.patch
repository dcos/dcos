From 0dad07c44c46b3a7f61848034ef0616a6086fa21 Mon Sep 17 00:00:00 2001
From: Greg Mann <greg@mesosphere.io>
Date: Fri, 6 Jul 2018 11:35:25 -0700
Subject: [PATCH] Added per-framework DRF position metrics to the allocator.

During each allocation cycle, the allocator re-sorts roles and
frameworks for each agent in the cluster. This means that for each
agent there exists a total order of (role, framework) tuples.

This patch adds per-framework, per-role metrics which track the
minimum and maximum positions attained by the framework in this
sorting process, from the most recent allocation cycle.

Review: https://reviews.apache.org/r/66861/
---
 src/master/allocator/mesos/hierarchical.cpp | 67 ++++++++++++++++++++++++++++-
 src/master/allocator/mesos/metrics.cpp      | 54 +++++++++++++++++++++++
 src/master/allocator/mesos/metrics.hpp      | 20 +++++++++
 3 files changed, 139 insertions(+), 2 deletions(-)

diff --git a/src/master/allocator/mesos/hierarchical.cpp b/src/master/allocator/mesos/hierarchical.cpp
index 5821e398d..1afa86a17 100644
--- a/src/master/allocator/mesos/hierarchical.cpp
+++ b/src/master/allocator/mesos/hierarchical.cpp
@@ -442,6 +442,7 @@ void HierarchicalAllocatorProcess::updateFramework(
     // no longer any resources allocated to it.
     if (frameworkSorters.at(role)->allocation(frameworkId.value()).empty()) {
       untrackFrameworkUnderRole(frameworkId, role);
+      framework.metrics->removeRole(role);
     }
 
     if (framework.offerFilters.contains(role)) {
@@ -1108,6 +1109,7 @@ void HierarchicalAllocatorProcess::recoverResources(
       if (frameworks.at(frameworkId).roles.count(role) == 0 &&
           frameworkSorter->allocation(frameworkId.value()).empty()) {
         untrackFrameworkUnderRole(frameworkId, role);
+        frameworks.get(frameworkId)->metrics->removeRole(role);
       }
     }
   }
@@ -1626,10 +1628,37 @@ void HierarchicalAllocatorProcess::__allocate()
   // allocated in the current cycle.
   hashmap<SlaveID, Resources> offeredSharedResources;
 
+  // Track the max and min DRF position of each framework in each role.
+  typedef hashmap<string, std::pair<size_t, size_t>> FrameworkPositions;
+
+  hashmap<string, FrameworkPositions> drfPositions;
+
+  auto setDrfPositions = [&drfPositions](
+      const string& role,
+      const string& frameworkId,
+      const size_t position) {
+    auto frameworks = drfPositions[role];
+    auto framework = frameworks.find(frameworkId);
+
+    if (framework == frameworks.end()) {
+      frameworks.emplace(frameworkId, std::make_pair(position, position));
+    } else {
+      framework->second.first = std::min(framework->second.first, position);
+      framework->second.second = std::max(framework->second.second, position);
+    }
+  };
+
+  // Used to set DRF position metrics for each (role, framework) tuple. This is
+  // reset at the beginning of each agent's allocation cycle so that we track
+  // the min and max values observed while allocating for all agents.
+  size_t currentPosition;
+
   // Quota comes first and fair share second. Here we process only those
   // roles for which quota is set (quota'ed roles). Such roles form a
   // special allocation group with a dedicated sorter.
   foreach (const SlaveID& slaveId, slaveIds) {
+    currentPosition = 1;
+
     foreach (const string& role, quotaRoleSorter->sort()) {
       CHECK(quotas.contains(role));
 
@@ -1682,7 +1711,13 @@ void HierarchicalAllocatorProcess::__allocate()
       CHECK(frameworkSorters.contains(role));
       const Owned<Sorter>& frameworkSorter = frameworkSorters.at(role);
 
-      foreach (const string& frameworkId_, frameworkSorter->sort()) {
+      const vector<string> sortedFrameworks = frameworkSorter->sort();
+
+      foreach (const string& frameworkId, sortedFrameworks) {
+        setDrfPositions(role, frameworkId, currentPosition++);
+      }
+
+      foreach (const string& frameworkId_, sortedFrameworks) {
         FrameworkID frameworkId;
         frameworkId.set_value(frameworkId_);
 
@@ -1950,6 +1985,8 @@ void HierarchicalAllocatorProcess::__allocate()
   // therefore can't be used to satisfy quota).
 
   foreach (const SlaveID& slaveId, slaveIds) {
+    currentPosition = 1;
+
     foreach (const string& role, roleSorter->sort()) {
       // In the second allocation stage, we only allocate
       // for non-quota roles.
@@ -1961,7 +1998,13 @@ void HierarchicalAllocatorProcess::__allocate()
       CHECK(frameworkSorters.contains(role));
       const Owned<Sorter>& frameworkSorter = frameworkSorters.at(role);
 
-      foreach (const string& frameworkId_, frameworkSorter->sort()) {
+      const vector<string> sortedFrameworks = frameworkSorter->sort();
+
+      foreach (const string& frameworkId, sortedFrameworks) {
+        setDrfPositions(role, frameworkId, currentPosition++);
+      }
+
+      foreach (const string& frameworkId_, sortedFrameworks) {
         FrameworkID frameworkId;
         frameworkId.set_value(frameworkId_);
 
@@ -2120,6 +2163,25 @@ void HierarchicalAllocatorProcess::__allocate()
     }
   }
 
+  // Update the per-framework DRF position metrics.
+  typedef std::pair<size_t, size_t> MinMax;
+  foreachpair (
+      const string& role,
+      const FrameworkPositions& frameworkMap,
+      drfPositions) {
+    foreachpair(
+        const string& frameworkId_,
+        const MinMax& minMax,
+        frameworkMap) {
+      FrameworkID frameworkId;
+      frameworkId.set_value(frameworkId_);
+
+      CHECK(frameworks.contains(frameworkId));
+
+      frameworks.at(frameworkId).metrics->setDrfPositions(role, minMax);
+    }
+  }
+
   if (offerable.empty()) {
     VLOG(1) << "No allocations performed";
   } else {
@@ -2695,6 +2757,7 @@ void HierarchicalAllocatorProcess::trackAllocatedResources(
     // track the framework under the role.
     if (!isFrameworkTrackedUnderRole(frameworkId, role)) {
       trackFrameworkUnderRole(frameworkId, role);
+      frameworks.get(frameworkId)->metrics->addRole(role);
     }
 
     CHECK(roleSorter->contains(role));
diff --git a/src/master/allocator/mesos/metrics.cpp b/src/master/allocator/mesos/metrics.cpp
index 8de9e16df..0dd0686c6 100644
--- a/src/master/allocator/mesos/metrics.cpp
+++ b/src/master/allocator/mesos/metrics.cpp
@@ -231,6 +231,12 @@ FrameworkMetrics::FrameworkMetrics(const FrameworkInfo& _frameworkInfo)
   process::metrics::add(resources_filtered_region_aware);
   process::metrics::add(resources_filtered_reservation_refinement);
   process::metrics::add(resources_filtered_revocable);
+
+  foreach (
+      const string& role,
+      protobuf::framework::getRoles(frameworkInfo)) {
+    addRole(role);
+  }
 }
 
 
@@ -242,6 +248,54 @@ FrameworkMetrics::~FrameworkMetrics()
   process::metrics::remove(resources_filtered_region_aware);
   process::metrics::remove(resources_filtered_reservation_refinement);
   process::metrics::remove(resources_filtered_revocable);
+
+  foreach (const string& role, roleDrfPositions.keys()) {
+    removeRole(role);
+  }
+
+  CHECK(roleDrfPositions.empty());
+}
+
+
+FrameworkMetrics::DrfPositions::DrfPositions(const string& prefix)
+  : min(prefix + "min"),
+    max(prefix + "max") {}
+
+
+void FrameworkMetrics::setDrfPositions(
+    const std::string& role,
+    const std::pair<size_t, size_t>& minMax)
+{
+  CHECK(roleDrfPositions.contains(role));
+
+  roleDrfPositions.at(role).min = minMax.first;
+  roleDrfPositions.at(role).max = minMax.second;
+}
+
+
+void FrameworkMetrics::addRole(const string& role)
+{
+  CHECK(!roleDrfPositions.contains(role));
+
+  roleDrfPositions.emplace(
+      role,
+      DrfPositions(
+          getFrameworkMetricPrefix(frameworkInfo) + "allocation/roles/" +
+            normalizeMetricKey(role) + "/latest_position/"));
+
+  process::metrics::add(roleDrfPositions.at(role).min);
+  process::metrics::add(roleDrfPositions.at(role).max);
+}
+
+
+void FrameworkMetrics::removeRole(const string& role)
+{
+  CHECK(roleDrfPositions.contains(role));
+
+  process::metrics::remove(roleDrfPositions.at(role).min);
+  process::metrics::remove(roleDrfPositions.at(role).max);
+
+  roleDrfPositions.erase(role);
 }
 
 } // namespace internal {
diff --git a/src/master/allocator/mesos/metrics.hpp b/src/master/allocator/mesos/metrics.hpp
index dfc7c8ec7..e28d17460 100644
--- a/src/master/allocator/mesos/metrics.hpp
+++ b/src/master/allocator/mesos/metrics.hpp
@@ -24,6 +24,7 @@
 
 #include <process/metrics/counter.hpp>
 #include <process/metrics/pull_gauge.hpp>
+#include <process/metrics/push_gauge.hpp>
 #include <process/metrics/timer.hpp>
 
 #include <process/pid.hpp>
@@ -97,6 +98,15 @@ struct FrameworkMetrics
 
   ~FrameworkMetrics();
 
+  void setDrfPositions(
+      const std::string& role,
+      const std::pair<size_t, size_t>& minMax);
+
+  // Since frameworks can update their list of roles upon reregistration,
+  // these methods add/remove per-role metrics.
+  void addRole(const std::string& role);
+  void removeRole(const std::string& role);
+
   const FrameworkInfo frameworkInfo;
 
   process::metrics::Counter resources_filtered;
@@ -105,6 +115,16 @@ struct FrameworkMetrics
   process::metrics::Counter resources_filtered_region_aware;
   process::metrics::Counter resources_filtered_reservation_refinement;
   process::metrics::Counter resources_filtered_revocable;
+
+  struct DrfPositions
+  {
+    DrfPositions(const std::string& prefix);
+
+    process::metrics::PushGauge min;
+    process::metrics::PushGauge max;
+  };
+
+  hashmap<std::string, DrfPositions> roleDrfPositions;
 };
 
 } // namespace internal {
-- 
2.14.1

