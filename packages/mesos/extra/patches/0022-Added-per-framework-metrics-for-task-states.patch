From e96a95a172c1641df5e752916437531fddb45ac5 Mon Sep 17 00:00:00 2001
From: Greg Mann <greg@mesosphere.io>
Date: Fri, 6 Jul 2018 11:34:57 -0700
Subject: [PATCH] Added per-framework metrics for task states.

Review: https://reviews.apache.org/r/67813/
---
 src/master/master.cpp  | 28 ++++++++++++++++-
 src/master/master.hpp  | 13 ++++++++
 src/master/metrics.cpp | 82 ++++++++++++++++++++++++++++++++++++++++++++++++++
 src/master/metrics.hpp | 14 +++++++++
 4 files changed, 136 insertions(+), 1 deletion(-)

diff --git a/src/master/master.cpp b/src/master/master.cpp
index 4f65db0ff..b8150cc73 100644
--- a/src/master/master.cpp
+++ b/src/master/master.cpp
@@ -8974,6 +8974,8 @@ void Master::updateTask(Task* task, const StatusUpdate& update)
   // task transitioned to a new state.
   bool sendSubscribersUpdate = false;
 
+  Framework* framework = getFramework(task->framework_id());
+
   // Set 'removable' to true if this is the first time the task
   // transitioned to a removable state. Also set the latest state.
   bool removable;
@@ -8987,6 +8989,14 @@ void Master::updateTask(Task* task, const StatusUpdate& update)
         sendSubscribersUpdate = true;
       }
 
+      if (task->state() != latestState.get() && framework != nullptr) {
+        // When we observe a transition away from a non-terminal state,
+        // decrement the relevant metric.
+        framework->metrics.decrementActiveTaskState(task->state());
+
+        framework->metrics.incrementTaskState(latestState.get());
+      }
+
       task->set_state(latestState.get());
     }
   } else {
@@ -9000,6 +9010,14 @@ void Master::updateTask(Task* task, const StatusUpdate& update)
         sendSubscribersUpdate = true;
       }
 
+      if (task->state() != status.state() && framework != nullptr) {
+        // When we observe a transition away from a non-terminal state,
+        // decrement the relevant metric.
+        framework->metrics.decrementActiveTaskState(task->state());
+
+        framework->metrics.incrementTaskState(status.state());
+      }
+
       task->set_state(status.state());
     }
   }
@@ -9050,7 +9068,6 @@ void Master::updateTask(Task* task, const StatusUpdate& update)
 
     slave->recoverResources(task);
 
-    Framework* framework = getFramework(task->framework_id());
     if (framework != nullptr) {
       framework->recoverResources(task);
     }
@@ -9098,6 +9115,15 @@ void Master::updateTask(Task* task, const StatusUpdate& update)
           status.source(),
           status.reason());
     }
+
+    if (protobuf::isTerminalState(status.state()) && framework != nullptr) {
+      if (status.has_source() && status.has_reason()) {
+        framework->metrics.incrementTerminalTaskReason(
+            status.state(),
+            status.source(),
+            status.reason());
+      }
+    }
   }
 }
 
diff --git a/src/master/master.hpp b/src/master/master.hpp
index 9bd9542a7..e1f4cf511 100644
--- a/src/master/master.hpp
+++ b/src/master/master.hpp
@@ -2337,6 +2337,19 @@ struct Framework
         trackUnderRole(role);
       }
     }
+
+    if (protobuf::isTerminalState(task->state()) &&
+        task->statuses().size() > 0) {
+      const TaskStatus& status = task->statuses(task->statuses().size() - 1);
+      if (status.has_source() && status.has_reason()) {
+        metrics.incrementTerminalTaskReason(
+            status.state(),
+            status.source(),
+            status.reason());
+      }
+    }
+
+    metrics.incrementTaskState(task->state());
   }
 
   // Update framework to recover the resources that were previously
diff --git a/src/master/metrics.cpp b/src/master/metrics.cpp
index 3686f6d24..50925decc 100644
--- a/src/master/metrics.cpp
+++ b/src/master/metrics.cpp
@@ -18,6 +18,7 @@
 
 #include <process/metrics/counter.hpp>
 #include <process/metrics/pull_gauge.hpp>
+#include <process/metrics/push_gauge.hpp>
 #include <process/metrics/metrics.hpp>
 
 #include <stout/foreach.hpp>
@@ -27,6 +28,7 @@
 
 using process::metrics::Counter;
 using process::metrics::PullGauge;
+using process::metrics::PushGauge;
 
 using std::string;
 
@@ -594,6 +596,30 @@ FrameworkMetrics::FrameworkMetrics(const FrameworkInfo& _frameworkInfo)
     update_event_task_states.put(state, counter);
     process::metrics::add(counter);
   }
+
+  // Add metrics for both active and terminal task states.
+  for (int index = 0; index < TaskState_descriptor()->value_count(); index++) {
+    const google::protobuf::EnumValueDescriptor* descriptor =
+      TaskState_descriptor()->value(index);
+
+    const TaskState state = static_cast<TaskState>(descriptor->number());
+
+    if (protobuf::isTerminalState(state)) {
+      Counter counter = Counter(
+          getFrameworkMetricPrefix(frameworkInfo) + "tasks/" +
+          strings::lower(descriptor->name()));
+
+      terminal_task_states.put(state, counter);
+      process::metrics::add(counter);
+    } else {
+      PushGauge gauge = PushGauge(
+          getFrameworkMetricPrefix(frameworkInfo) + "tasks/" +
+          strings::lower(TaskState_Name(state)));
+
+      active_task_states.put(state, gauge);
+      process::metrics::add(gauge);
+    }
+  }
 }
 
 
@@ -619,6 +645,22 @@ FrameworkMetrics::~FrameworkMetrics()
   process::metrics::remove(offers_accepted);
   process::metrics::remove(offers_declined);
   process::metrics::remove(offers_rescinded);
+
+  foreachvalue (const auto& sourceReason, terminal_task_reasons) {
+    foreachvalue (const auto& reasonCounter, sourceReason) {
+      foreachvalue (const Counter& counter, reasonCounter) {
+        process::metrics::remove(counter);
+      }
+    }
+  }
+
+  foreachvalue (const Counter& counter, terminal_task_states) {
+    process::metrics::remove(counter);
+  }
+
+  foreachvalue (const PushGauge& gauge, active_task_states) {
+    process::metrics::remove(gauge);
+  }
 }
 
 
@@ -631,6 +673,46 @@ void FrameworkMetrics::incrementCall(const scheduler::Call::Type& callType)
 }
 
 
+void FrameworkMetrics::incrementTaskState(const TaskState& state)
+{
+  if (protobuf::isTerminalState(state)) {
+    CHECK(terminal_task_states.contains(state));
+    terminal_task_states.get(state).get()++;
+  } else {
+    CHECK(active_task_states.contains(state));
+    active_task_states.get(state).get() += 1;
+  }
+}
+
+
+void FrameworkMetrics::incrementTerminalTaskReason(
+    const TaskState& state,
+    const TaskStatus::Source& source,
+    const TaskStatus::Reason& reason)
+{
+  if (!terminal_task_reasons[state][source].contains(reason)) {
+    Counter counter = Counter(
+        getFrameworkMetricPrefix(frameworkInfo) + "tasks/" +
+        strings::lower(TaskState_Name(state)) + "/" +
+        strings::lower(TaskStatus::Source_Name(source)) + "/" +
+        strings::lower(TaskStatus::Reason_Name(reason)));
+
+    terminal_task_reasons[state][source].put(reason, counter);
+    process::metrics::add(counter);
+  }
+
+  terminal_task_reasons[state][source].get(reason).get()++;
+}
+
+
+void FrameworkMetrics::decrementActiveTaskState(const TaskState& state)
+{
+  CHECK(active_task_states.contains(state));
+
+  active_task_states.get(state).get() -= 1;
+}
+
+
 string normalizeMetricKey(const string& key)
 {
   string name = strings::lower(key);
diff --git a/src/master/metrics.hpp b/src/master/metrics.hpp
index 263796a21..9576bb1f9 100644
--- a/src/master/metrics.hpp
+++ b/src/master/metrics.hpp
@@ -219,6 +219,13 @@ struct FrameworkMetrics
 
   void incrementEvent(const scheduler::Event& event);
 
+  void incrementTaskState(const TaskState& state);
+  void incrementTerminalTaskReason(
+      const TaskState& state,
+      const TaskStatus::Source& source,
+      const TaskStatus::Reason& reason);
+  void decrementActiveTaskState(const TaskState& state);
+
   const FrameworkInfo frameworkInfo;
 
   process::metrics::PushGauge subscribed;
@@ -234,6 +241,13 @@ struct FrameworkMetrics
   process::metrics::Counter offers_accepted;
   process::metrics::Counter offers_declined;
   process::metrics::Counter offers_rescinded;
+
+  typedef hashmap<TaskStatus::Reason, process::metrics::Counter> Reasons;
+  typedef hashmap<TaskStatus::Source, Reasons> SourcesReasons;
+  hashmap<TaskState, SourcesReasons> terminal_task_reasons;
+  hashmap<TaskState, process::metrics::Counter> terminal_task_states;
+
+  hashmap<TaskState, process::metrics::PushGauge> active_task_states;
 };
 
 
-- 
2.14.1

