# Creating and Maintaining Packages
Pkgpanda packages are XZ-compresssed tarballs, containing (optionally) a metadata file `pkginfo.json` as well as several well-known directories. See [Package Concepts](package_concepts.md) for a full listing, as well as descriptions of each section should be used for. Packages are built in docker images (which can be customized) according to the requiried `build` script and `buildinfo.json` files included witht the source packages in the [package store](../../packages)

Every package lives in isolation from other packages, and can be installed/uninstalled atomically.

Packages are built with a metadata file `pkginfo.json`, and every package has a *Package Name* as well as a *Package
Id*.

The `pkginfo.json` contains packages depending on each other.
Packages are always extracted and run from a predictable location. The standard prefix is
`/opt/mesosphere/{name}--{version}/`, where `{name}--{version}` is the full package ID. This path will be the install prefix for the package. A package may rely on the absolute path to the package contents remaining constant.

Only one package of a given package name may be active on a system at a given time. If a package is not active, then
there is no guarantee that the package is available on the machine, and files in it should not be referenced.

Pkgpanda operates by swapping out (roughly atomically) one set of active packages for another and starting the associated package systemd units.

Packages are declared in the [package store](../../packages) where they can be organized into sets called [trees](tree_concepts.md)

## Building the Package
### Developing Packages
When building a release, `pkgpanda` is only called through its library. However, there is a CLI which is very helpful for developing and debugging packages. To setup pkgpanda locally, be sure docker is installed and able to run without sudo, then run the `./prep_local` script in the root directory (python virtualenv will be required). Finally, make sure the dcos-builder image has been prepped locally by doing `cd pkgpanda/docker/dcos-builder/ && docker build -t dcos/dcos-builder:dcos-builder_dockerdir-latest .` Right now, this is handled apart of the release scripting, not pkgpanda.

As soon as `./prep_local` finishes, the `mkpanda` command will be available to use. With this, you can navigate to a specific package directory and simply run `mkpanda`. This will instruct pkgpanda to look at the given package, evaluate its dependency list, build those if necessary, and then finally build the chosen package.

From the `packages` directory, one can run `mkpanda tree` which will essentially do a full, locally-cached DC/OS build. Alternatively, one can name a variant tree like so: `mkpanda tree installer`. This will instruct pkgpanda to only make the packages necessary for building the completed variant.

### Package Contents
Each directory in the package tree is a package and must, therefore, have two things:
* `buildinfo.json`: This file describes the code sources, the dependent packages, and the docker image in which the package will be built. This file can also declare a package as a service requiring state or a user account.
* `build`: this is the script that will be executed inside a container of the image described in the buildinfo.json. There are some magic environment variables and paths (see below) that allow accessing the sources declared in the `buildinfo.json`, referencing configuration options and other packages, and exporting artifacts generated by the `build` script.

Optionally, packages may have these folders:
* `docker`: for customizing the docker image that the package is built in (see below)
* `extra`: a folder of arbitrary data that will be volume mounted to the build container

To actually get the artifacts generated in this process, they must be moved into the folder referenced by `$PKG_PATH` in the build container. The contents of the `$PKG_PATH` directory will be compressed into a package. This package can have directories called `bin` and `lib` that will be symlinked into the run-time `PATH` and `LD_LIBRARY_PATH`.


### Sources
Sources are singular artifacts or git repositories that are required to complete the package build. They are described via JSON maps with variable fields; the only guaranteed field is `kind`. There are a few differnt kinds of sources:
* `git`: Points to a git repository which can be private if the build host git client is configured correctly. Required fields: `kind`, `url`, `ref`, `ref_origin`. `ref` is the commit from the repo that should be built and `ref_origin` is the branch on which that commit lives.
* `git_local`: A filesystem-local git repository that may have been pulled in by a process outside gen/release. Required fields: `kind` and `rel_path`
* `url`: URL of a singular artifact to download and volume mount inside the build container. Required fields: `kind`, `url`, `sha1`. `sha1` is the SHA-1 checksum of the artifact and can be found by downloading the artifact and running `sha1sum <<my_artifact>>`
* `url_extract`: URL to an artifact that is a compressed file which will be automatically decompressed before volume mounting. Supported compression types are: `.tar.gz`, `.tgz`, and `.zip`. Required fields are: `kind`, `url`, and `sha1`

Rules for declaring sources in `buildinfo.json`:
* If there are no required dependencies outside of the package directory, then no source information is required in `buildinfo.json`
* If there is only one source, a `single_source` field must be included in the `buildinfo.json`. The data from this source will be mounted inside the container as `/pkg/src/$PKG_NAME`
* If there are multiple sources, a `sources` field must be provided in `buildinfo.json` and each of its subfields will be a source like the single source entry. Each of these sources will be mounted in the container as `/pkg/src/<<key name of source in JSON sources>>`

### Customized Docker Build Images

By default, all packages are built with the [dcos-builder Dockerfile](../pkgpanda/docker/dcos-builder). A different docker image can be specified. There are two ways to specify a different docker image:
* include a directory called `docker` alongside the `build` and `buildinfo.json`. This file must contain a Dockerfile and any necessary data to be included with the image. This docker image will be built as part of the package building process and will be named as `dcos/dcos-builder:<<package_name>>_dockerdir-latest` where `<<package_name>>` is the package being built.
* reference a public DockerHub image in the `buildinfo.json`

### Magic Paths and Variables in Build Containers
* `/pkg/src/`: directory for all sources declared in `buildinfo.json`
* `/pkg/extra/`: mounted `extra` directory from the package folder
* `/opt/mesosphere/environment.export`: file including the environment variables that will link the build container environment to built packages and their artifacts. Most builds depending on other packages should source the environment with this file
* `/opt/mesosphere`: the partially constructed DC/OS installation directory as it will be unpacked on hosts
* `/opt/mesosphere/packages`: the location of all packages that were listed as dependencies.
* `/opt/mesosphere/lib`: combined lib path of exported artifacts from the depedent packages. I.E. the data transferred to `$PKG_PATH/lib` combined across packages
* `/opt/mesosphere/bin`: combined bin path of exported artifacts from the depedent packages. I.E. the data transferred to `$PKG_PATH/bin` combined across packages
* `$PKG_NAME`: the name of the package folder
* `$PKG_PATH`: the writable path for build artifacts

### Package Variants
In any given package, one may add a `foobar.buildinfo.json` that will pull in alternative sources to run against the same `build` script. This would create a `foobar` variant of the given package. By default, all packages are of the `default` variant, so to build package variants, learn more about [build trees](tree_concepts.md).
